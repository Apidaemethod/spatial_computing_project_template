<img src="/img/logo/apidae_black.png" alt="collective" style="width:280px;"> 
<center> <img src="/img/logo/apidae_with_text.png" alt="collective" style="width:600px;"> </center>

A <img src="/img/midterm/lowreshighres.png" style="width:280px;">
B <img src="https://cdn.discordapp.com/attachments/784009094474366977/803248102412779550/entrances.jpg" style="width:280px;">
C <img src="https://cdn.discordapp.com/attachments/784009094474366977/803249271100014612/unknown.png" style="width:280px;">

1<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/0.0_basecontext.png?raw=true" style="width:280px;">

2<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/0.0_mesh.png?raw=true" style="width:280px;">

3<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/0.1_fulllattice.png?raw=true" style="width:280px;">


4<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/2.0_skyaccess.png?raw=true" style="width:280px;">


5<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/2.0_skyview.png?raw=true" style="width:280px;">


6<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/2.1.0_selection.png?raw=true" style="width:280px;">


7<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/2.1.1_removed.png?raw=true" style="width:280px;">


8<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/2.2_newfulllattice.png?raw=true" style="width:280px;">


9<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/3.1.0_sunaccess.png?raw=true" style="width:280px;">


10<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/3.1.2_shadow.png?raw=true" style="width:280px;">


11<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/3.2_quietness.png?raw=true" style="width:280px;">


12<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/3.3_lattice_public_entrances.png?raw=true" style="width:280px;">

13<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/3.4_lattice_gym.png?raw=true" style="width:280px;">

14<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/3.5_lattice_parking_entrance.png?raw=true" style="width:280px;">

15<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/3.6_lattice_housing.png?raw=true" style="width:280px;">

16<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/3.7_lattice_comcen_entrance.png?raw=true" style="width:280px;">

17<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/4.1_average_voxel_value.png?raw=true" style="width:280px;">

18<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/4.1_averagevoxelval.png?raw=true" style="width:280px;">

19<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/4.2_new_avail_lattice.png?raw=true" style="width:280px;">

20<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/5.1_corridors_groundfloor.png?raw=true" style="width:280px;">

21<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/6.1_corridors_groundfloor.png?raw=true" style="width:280px;">

22<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/6.1_corridors_upper_floors.png?raw=true" style="width:280px;">

23<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/6.2_lattice_distance_communal_functions.png?raw=true" style="width:280px;">

24<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/6.2_lattice_distance_upper_floors.png?raw=true" style="width:280px;">

25<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/6.3_shafts.png?raw=true" style="width:280px;">

26<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/6.4_all_shafts_and_corridors.png?raw=true" style="width:280px;">

27<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/6.4_shafts_and_corridors.png?raw=true" style="width:280px;">

28<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/6.4_shafts_and_corridors_in_boudningbox.png?raw=true" style="width:280px;">

29<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/7.0_initialization.png?raw=true" style="width:280px;">

30<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/7.0_initialization_with_lattice.png?raw=true" style="width:280px;">

31<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/7.0_time0.png?raw=true" style="width:280px;">

32<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/7.0_time100.png?raw=true" style="width:280px;">

33<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/7.0_time500.png?raw=true" style="width:280px;">

34<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/7.0_time1000.png?raw=true" style="width:280px;">

35<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/7.0_time2500.png?raw=true" style="width:280px;">

36<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/midterm/trap.jpg?raw=true" style="width:280px;">

37<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/midterm/TRAP_2.jpg?raw=true" style="width:280px;">

38 <iframe src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/growthgif.gif?raw=true" style="width:150%; height:400px;" frameborder="0"></iframe>

39 <iframe src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/ezgif-3-5e6cbec2a182.gif" style="width:150%; height:400px;" frameborder="0"></iframe>

40 <iframe src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/calcgifs.gif?raw=true" style="width:150%; height:400px;" frameborder="0"></iframe>


# Process of massing

## Solar Simulation & Shadow Analysis
Based on the ladybug sunpath the solar and shadow envelope are calculated in one file, since they have a largely corresponding steps. To do so a cast a ray from the centroid of the voxel towards all the points on the sunpath. If a ray is not intersected by the context, then this voxel receives sunlight from this point. If the ray is intersected by the context, then the voxel does not receive sunlight from this point. For all the voxel that have been hit, the rays that were shot towards the sun are reversed, to calculate the shadow. If this ray intersects the context, then the voxel casts a shadow. If the ray does not intersect the context, then the voxel does not cast a shadow. Both the sunlight and the shadow envelope are then interpolated to a highres value, being of our voxel size.  

### Lowres size decisions
In the first run of the interpolated shadow file,  a low res envelope of 2 voxels high was used. This resulted in the shadow casting calculation becoming much to generalized. In this situation it would see the entire bottom half of the building as not casting shadow on the neighbouring buildings, thus not showing them in the shadow casting and only showing the top half of the building in the visualisation. To solve this problem a lowres envelope of 3 voxels high was used. This resulted in a visualisation of the entire envelope.  

<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/midterm/lowreshighres.png?raw=true" style="width:280px;">

## Skylight & Skylight blocking
This script is very similar to the Solar simulation, but instead of loading a sunpath, a sphere is created to represent points in the sky. For each voxel a ray is cast from the centroid of the voxel towards all the points in the sky.  If a ray is not intersected by the context, then this voxel receives skylight from this point. If the ray is intersected by the context, then the voxel does not receive skylight from this point. For all the voxel that have been hit, the rays that were shot towards the sky are reversed, to calculate the skylight blocking. If this ray intersects the context, then the voxel casts blocks skylight from the context. If the ray does not intersect the context, then the voxel does not block skylight from the context. Both the skylight and the skylight blocking envelope are then interpolated to a highres value, being of our voxel size.


### difference between shadow and solar
The result of the shadow envelope, solar envelope, skylight envelope and skylight blocking envelope  are processed in 2 ways. Fundamentally we want our building to be of least disturbance for the surrounding area, so it would not make sense to keep voxels that cast too much shadow or block too much skylight. This is why we remove the voxels that cast too much shadow and block too much skylight from the context. 
For the sun and skylight values a similar argument could be made. For sake of the building one could argue that only the voxels with the best sun and skylight access should be used. However, this would result in removing the voxels on the ground floor. Since building can’t float in the sky(yet), and for the accessibility of public functions its best to have them on the ground floor, the data of sunlight and skylight is stored inside the voxels for the growth model (link to growth model). 


### Removing voxels
To not cause too much shadow or block too much skylight from the context, the voxels that cast too much shadow or block too much skylight from the context, are removed from the envelope based on a threshold. This results in a new envelope without the “bad voxels” 

<iframe src="https://thumbs.gfycat.com/ValidImaginativeChihuahua-size_restricted.gif" style="width:150%; height:430px;" frameborder="0"></iframe>



##  Sun and Skylight improvements
Although these scripts are functional, there are still some improvements that could be made. 
    -	Taking into account the influence of voxels inside the envelope on the sun/skylight and shadow/ skylight blocking. 
        o	For the initial stage of storing data and removing voxels, solely using the influence of the context on the voxels to be blocking sun or skylight is sufficient. But for later stages when the building is generated (link to growth model), it would be an improvement to take the influence of light and shadow of voxels on each other. This would make that script even heavier, because it will have to calculate a light and shadow value each time it adds voxels. Besides that, a distinction should made with the outer voxels and inner voxels, to have some depth in the building. This depth should also be specified. To solve this, the growth model could be normally ran at first, and then after it has finished going through an evaluation loop to check the shadow and skylight blocking on the context.
    -	Removing bad voxels based on the shadow the context receives instead of the percentage of the time voxels cause shadow.  
        o	As of now a threshold is specified to remove voxels from the envelope based on the percentage of time these voxels cast shadow and block skylight from the context. However it would be an improvement if the voxels are removed based on the effect they have on the context. If a voxel casts a shadow on the context 50% of the time, this could mean that it causes it on a different building each time, meaning that although the voxel looks “bad”, the net result on the context is negligible. This calculation should also be taken into the growth model (link to growth model). This does mean this script will become even more heavy as it now has to calculate the shadow and skylight blocking each time it grows as well. To solve this, the growth model could be normally ran at first, and then after it has finished going through an evaluation loop to check the shadow and skylight blocking on the context. 


## Quietness
To calculate the quietness noise in the building in relation to it’s context a path with noise points on it is loaded inside a script. Each voxel then calculates the distance from the voxel centroid towards the noise point. These distances are added together and converted into a ratio. This script is actually more about business on street level than about quietness, since it imports noise points and not actual decibels from areas. This does not matter too much, since noise could be filtered from a building by adding more insulation and the relative quietness matters more than the actual numbers in decibels.


## greenery
<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/midterm/greenery.png?raw=true" style="width:280px;">

## Shafts
<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/midterm/shafts.png?raw=true" style="width:280px;">

## Corridors

## entrances
<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/midterm/entrances.png?raw=true" style="width:280px;">


## Shortest path
Not sure if needed, but perhaps explain the approach? (for example taking an entire line instead of only one voxel as an entrance)


________________________________________________

NOTEPAD FOR ABM ETC

________________________________________________



## **KPI's to agent criteria** 
explain what our criteria for the agents are and how they relate to the KPI's
The following criteria have been implemented in the agent based simulation:

* Matrix based relations between spaces (Collectivity)
* Sun access (Home quality) + (Sustainability)
* Entrance distance for public, housing, gym, parking and communal spaces (Diversity in audience) 
* The heights of the spaces (Home quality)
* The desired area requirements per space (Program of requirements)
* Skyview (Home quality)
* Greenery (Sustainability)
* Noise (Home quality) + (Collectivity) + (Sustainability)


## **Configuring spaces to workable values**
In order to implement the design criteria as mentioned before, those had to be converted to workable values. The values have been written for each space versus the criteria varying from 0 to 1. 0 indicates no connection, 1 indicates a strong connection (Referencing back to the matrix from A1_Configuring). This has been applied for the following criteria: matrix based relations between spaces, sun access, entrance distance for public, housing, gym, parking and communal spaces, skyview, greenery and noise. 

For the space heights and space areas a different approach had to be made since those are hardcoded criteria coming from the Program of Requirements. Hence, those explained in the next paragraph. 

### **Space heights to stencils **
In order to implement the height differences of spaces given from the Porgram of Requirements into the Apidae method, the initial given stencil (see left stencil in the picture below) has been expanded in the z axes. In the code, this has been done for 1, 2, 3, 4 and 5 voxels high. The highest stencil is 5 x 1.8m = 9 meters into the z axis and 1.8m on the x and y axis.

<img src="https://cdn.discordapp.com/attachments/784009094474366977/803249271100014612/unknown.png">

The creation of the new stencils can be created with the following piece of code:
In this piece of code new neighbours have been defined for the stencils that need to be higher than 1.8m. For example, s_2 has it's z axis neighbor now set at 2 high. Beware that later in the growth model, the occupation has to be adjusted accordingly.

```python
# creating neighborhood definition for stencil that is 1.8m high
s_1 = tg.create_stencil("von_neumann", 1, 1)

# setting the center to zero
s_1.set_index([0,0,0], 0)

#####################################################################
# skipping s_2, s_3, s_4 for this example because it's the same way
#####################################################################

# creating neighborhood definition for stencil that is 9m high
s_5 = tg.create_stencil("von_neumann", 1, 5)
# setting the center to zero
s_5.set_index([0, 0, 0], 0)
s_5.set_index([0, 0, 1], 0)
s_5.set_index([0, 0, 5], 1)
s_5.set_index([0, 0,-1], 0)
s_5.set_index([0, 0,-5], 1)

# setting the center to zero
s_5.set_index([0,0,0], 0)

# listing the stencils in order to make them correspond later with the spaces and their height requirement
stencils = [s_1, s_2, s_3, s_4, s_5]
```

### **Space areas to voxel amounts**
Based on the program of requirements, the required space sizes have been coverted to amount of necessary voxels to meet the area requirement and therefore fulfil it. This has been implemented in the script to maintain the desirded area per spaces, and has been used to limit the growth of the agents. 
From the Program of Requirements the room areas can be obtained, and by giving every space a stencil id according to the desired free height (as explained before how the desired height can be implemented) the total amount of voxel necessary for the space to grow towards can be determined. This can be done with the following piece of code:

```python
# max voxel count per space (here we do the stencil type + 1 
#times the amount of area needed in order to obtain the total amount of voxels that need to be occupied by the script)
# pick room area data
a_room_vox = agn_prefs["room_area"]
# pick stencil id's and do +1 because we start with 0 instead of 1 (id 2 would have stencil 3 high otherwise)
a_room_stencil = agn_prefs["stencil_id"] + 1
# obtain the max amount of voxels needing to be occupied by doing the room area times the height of the space (stencil)
a_room_voxels = a_room_stencil * a_room_vox
# print in order to check below if you obtain correct values
print(a_room_voxels)
``` 
Which gives the following table that can be used later in the growth model:

<center> <img src="https://cdn.discordapp.com/attachments/784009094474366977/803255219545964564/unknown.png"></center>

## **Definitive program table result (input for generative relations simulation)**
The following table has been made based on the agent/space criterias, this has been used in the definitive script for generating the agent based design. 

4 kinds of values are included next to [white] the agent/space names and space id's:

1. [blue] Desire to closeness to given entrance (0 to 1)
2. [yellow] Desire for high values of the given analysis (0 to 1)
3. [green] Necessary data from the program of requirements (imput specific values)
4. [grey] Desire to be close to given agent/space (0 to 1)

The given entrances for blue and given analysis for yellow are loaded in as csv files. For the making of those csv files, address their corresponding script.

<iframe src="https://docs.google.com/spreadsheets/d/e/2PACX-1vR3BSCNWlacKeNAtlluEjTCw5SMh3Tet-m3ixMxbSwR_aIhWDu0YJLZGvVQdgqWNg/pubhtml?gid=1634426511&amp;single=true&amp;widget=true&amp;headers=false"style="width:150%; height:600px;"></iframe>


________________________________________________

# **The Generative Relations Simulation**
Since we have a bunch of data and values corresponding to that per agent, and we need to make decisions based on that (design wise), the script for the Multiple-criteria decision analysis for agents was used and further developed to our needs.  

## **How it works**
-INSERT HERE THE FLOWCHART-

scuffed text incoming herschrijf:
The growth model works as following:
We run it for a given timeframe, and for each agent we evaluate the free voxels in the list and store this data
After this, we start another for loop aka the main agent loop, where we retrieve the free neighbours access them and make sure it doesnt exceed given values such as the Z coordinate
. After this is done, if there is a free neighbour found it checks the preferences and evaluates it with the fuzzy framework. And after this there’s 2 scenarios; the max area limit has not been reached yet so it picks the highest value neighbouring voxel. Else, it checks if there are better voxels to be occupied (if the given evaluation limit is higher than the agent satisfaction; it departs that bad voxel and occupies the new one. After this is done for all time frames, the new lattice is constructed with the occupation lattice. Which is the final result as I’ve shown before.

### **Different occupation per stencil**
### **Evaluation**

